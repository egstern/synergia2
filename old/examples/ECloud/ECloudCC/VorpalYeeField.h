#ifndef HAVE_ECLOUD_VORPALYEEFIELD_H
#define HAVE_ECLOUD_VORPALYEEFIELD_H
#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
#include "scalar_field.h"

//
// Interface between Vorpal and Synergia.  This reads the Electric and/or magnetic field 
// from HDF5 files generated by Vorpal, and fills a scalar field.   
//
//  

class VorpalYeeField {

// While the first one or two arguments in these contructors are self-obvious, the last one is not. 
// If true (default), it is assume that a Dirichlet boundary condition (or equivalent) has been applied to the problem, 
// and the following correction is made for the Electric field: On a Yee lattice, 
// (Yee, K. S., \u201cNumerical solution of initial boundary value problems involving maxwell\u2019s equations in
// isotropic media,\u201d IEEE Transaction of Antennas and Propagation, vol. 14, p. 302-307, 1966.)
// the Electric field is on the edge, not at the center of the cell. 
// Synergia expect the field defined at the center of the cell, I suspect. 
// We assume a symmetry exist in the problem, where the E field is relatively flat in the center of the 
// physical sapce on which the Yee lattice is defined.  So the field along X at the center of the cell, 
// left side (low index) E_i = (E_i + E_{i+1})/2. and one the right side, high index value it is 
// E_i = (E_i + E_{i-1})/2..  At the center, if the field is relatively flat, either formula can be used.. 
// 
 
  public:
    VorpalYeeField(const char* fNameField, bool isElectric, bool withYeeCorrection=true); // Either B field or E field 
    VorpalYeeField(const char* fNameElectricField, const char* fNameMagneticField, bool withYeeCorrection=true);
    ~VorpalYeeField();
 
    void addCstEField(const std::vector<double> eField);
 
    double getEField(const std::vector<double> location, int iComp) const; // x=0, y=1, z=2
    double getBField(const std::vector<double> location, int iComp) const; // x=0, y=1, z=2
       
    std::vector<int> getDims() const; 
    std::vector<double> getPhysSize() const ; 
    std::vector<double> getPhysOffset() const ; 
        
    inline double getEFieldX(const std::vector<double> location)  const { 
      return getEField(location, 0);
    }
    inline double getEFieldY(const std::vector<double> location)  const { 
      return getEField(location, 1);
    }
    inline double getEFieldZ(const std::vector<double> location)  const { 
      return getEField(location, 2);
    }
    inline double getBFieldX(const std::vector<double> location)  const { 
      return getBField(location, 0);
    }
    inline double getBFieldY(const std::vector<double> location)  const { 
      return getBField(location, 1);
    }
    inline double getBFieldZ(const std::vector<double> location)  const { 
      return getBField(location, 2);
    }
    inline void setDebungOn(bool dOn) {debugIsOn = dOn;}
    
  private:
  
    bool BFieldDefined;
    bool EFieldDefined;
    bool yeeCorr;
    bool debugIsOn;
  
    Real_scalar_field *Ex;
    Real_scalar_field *Ey;
    Real_scalar_field *Ez;
       
    Real_scalar_field *Bx;
    Real_scalar_field *By;
    Real_scalar_field *Bz;
    
    void constructEField(const char* fNameEField); 
    void constructBField(const char* fNameBField);
     
    static const std::string DATASET_ENAME;  
    static const std::string DATASET_BNAME;
      
};
#endif
