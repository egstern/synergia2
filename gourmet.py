#!/usr/bin/env python

import local_paths

from basic_toolkit import *
from mxyzptlk import *
from beamline import *
from physics_toolkit import *
from bmlfactory import *
from physics_constants import *
import mappers

import math
import sys
import Numeric

accuracy_marker = marker("accuracy")
space_charge_marker = marker("space charge")
pacifier = drift("pacifier",0.0)

class Gourmet:
    def __init__(self, mad_file, line_name, kinetic_energy, scaling_frequency,
                 order=1):
        self.scaling_frequency = scaling_frequency
        self.order = order
        Jet.BeginEnvironment(self.order)
        x    = coord(0.0)
        y    = coord(0.0)
        ct   = coord(0.0)
        npx  = coord(0.0)
        npy  = coord(0.0)
        np   = coord(0.0)
        JetC.setLastEnv(JetC.CreateEnvFrom(Jet.EndEnvironment()))

        # Notice that our particle is hard-wired to be a Proton
        # This will have to be fixed once the various particle issues
        # have been resolved
        self.kinetic_energy = kinetic_energy
        self.mass = PH_NORM_mp
        self.energy = kinetic_energy + self.mass
        self.momentum = math.sqrt(self.energy*self.energy -
                                  self.mass*self.mass)
        self.particle = Proton(self.energy)
        self.jet_particle = JetProton(self.energy)

        self.factory = bmlfactory(mad_file)
        beamline_orig = self.factory.create_beamline(line_name,
                                                     self.particle.ReferenceBRho())
        beamline_orig.flatten()
        beamline_orig.insert(pacifier)
        beamline_orig.append(pacifier)
        self.beamline = DriftsToSlots(beamline_orig)
        self.have_mappings = 0
        self.have_linear_maps = 0
        self.have_fast_mappings = 0
        self.context = BeamlineContext(0,self.beamline)
        if not self.context.isTreatedAsRing():
            self.context.handleAsRing()

        self.iterator = DeepBeamlineIterator(self.beamline)

    def _commission(self):
### The following is in reaction to the message:
### *** WARNING ***
### *** WARNING *** File: CF_sbend.cc, Line: 536
### *** WARNING *** void sbend::Split( double pc, bmlnElmnt** a, bmlnElmnt** b )
### *** WARNING *** The new, split elements must be commissioned with
### *** WARNING *** RefRegVisitor before being used.
### *** WARNING ***
### generated by insertions.
        compulsory_visitor = RefRegVisitor(self.particle)
        self.beamline.accept(compulsory_visitor)
        
    def insert_markers(self, num_markers_per_element):
        master_insertion_point = 0.0
        insertion_list = InsertionList(self.momentum)
        self.iterator.reset()
        element = self.iterator.next()
        ile_list = []
        while element:
                if element.OrbitLength(self.particle) > 0:
                        marker_interval = element.OrbitLength(self.particle)/ \
                        (num_markers_per_element + 1.0)
                        insertion_point = master_insertion_point
                        for i in range(0,num_markers_per_element):
                                insertion_point += marker_interval
                                ile = InsertionListElement(insertion_point,
                                                           accuracy_marker)
                                ile_list.append(ile)
                                insertion_list.Append(ile)
                master_insertion_point += element.OrbitLength(self.particle)
                element = self.iterator.next()
        removed_elements = slist()
        s_0 = 0.0
        self.beamline.InsertElementsFromList(s_0, insertion_list,
                                             removed_elements)
        self.beamline.append(accuracy_marker)
        self._commission()
        
    def orbit_length(self):
        return self.beamline.OrbitLength(self.particle)
    
    def insert_space_charge_markers(self, num_markers):
        insertion_list = InsertionList(self.momentum)
        marker_interval = self.orbit_length()/ \
                          num_markers
        insertion_point = 0.0
        ile_list = []
        for i in range(0,num_markers):
            ile = InsertionListElement(insertion_point,space_charge_marker)
            ile_list.append(ile)
            insertion_list.Append(ile)
            insertion_point += marker_interval
        removed_elements = slist()
        s_0 = 0.0
        self.beamline.InsertElementsFromList(s_0, insertion_list,
                                             removed_elements)
        self.beamline.append(space_charge_marker)
        self._commission()

    def print_elements(self):
        self.iterator.reset()
        i = 0
        element = self.iterator.next()
        while element:
            print i, element.Name(), element.Type()
            element = self.iterator.next()
            i += 1

    def get_lattice_functions(self):
        lattice_function_array = Lattice_function_array()
        self.iterator.reset()
        i = 0
        element = self.iterator.next()
        while element:
            lattice_function = self.context.getLattFuncPtr(i)
            if lattice_function:
                lattice_function_array.append(lattice_function)
            element = self.iterator.next()
            i += 1
        return lattice_function_array

    def generate_mappings(self):
        self.mappings = []
        self.iterator.reset()
        element = self.iterator.next()
        jet_proton = None
        while element:
            if element.Name() == "space charge":
                if jet_proton:
                    self.mappings.append(jet_proton.State())
                jet_proton = JetProton(self.energy)
            else:
                if jet_proton:
                    element.propagateJetParticle(jet_proton)
            element = self.iterator.next()
        self.have_mappings = 1
        
    def delete_mappings(self):
        self.mappings = []
        self.have_mappings = 0

    def get_mapping(self, index):
        if not self.have_mappings:
            self.generate_mappings()
        return self.mappings[index]
    
    def _convert_linear_maps(self, chef_linear_maps):
        # units conversion
        # X_impact = U X_external
        # where U = diag(u[0],u[1],u[2],u[3],u[4],u[5])
        u = self.get_u()
        linear_maps = []
        for chef_map in chef_linear_maps:
            map = Numeric.zeros((7,7),'d')
            for row in range(0,6):
                for column in range(0,6):
                    chef_row = int(row/2+3*(row%2))
                    chef_column = int(column/2+3*(column%2))
                    map[row,column] = chef_map[chef_row,chef_column]* \
                                      u[row]/u[column]
            map[6,6] = 1.0
            linear_maps.append(map)
        return linear_maps
    
    def generate_linear_maps(self, keep_mappings=0):
        chef_linear_maps = []
        if not self.have_mappings:
            self.generate_mappings()
        for mapping in self.mappings:
            chef_linear_maps.append(mapping.Jacobian())
        self.linear_maps = self._convert_linear_maps(chef_linear_maps)
        self.have_linear_maps = 1
        if not keep_mappings:
            self.delete_mappings()

    def delete_linear_maps(self):
        self.linear_maps = []
        self.have_linear_maps = 0

    def get_linear_map(self,index):
        if not self.have_linear_maps:
            self.generate_linear_maps()
        return self.linear_maps[index]

    def generate_fast_mappings(self, keep_mappings=0):
        self.fast_mappings = []
        if not self.have_mappings:
            self.generate_mappings()
        u = self.get_u()
        for mapping in self.mappings:
            self.fast_mappings.append(mappers.Fast_mapping(u,mapping))
        self.have_fast_mappings = 1
        if not keep_mappings:
            self.delete_mappings()

    def delete_fast_mappings(self):
        self.fast_mappings = []
        self.have_fast_mappings = 0

    def get_fast_mapping(self, index):
        if not self.have_fast_mappings:
            self.generate_fast_mappings()
        return self.fast_mappings[index]

    def get_u(self):
        gamma = self.energy/self.mass
        beta = math.sqrt(1.0 - 1.0/(gamma*gamma))
        c = PH_MKS_c
        w = 2.0* math.pi* self.scaling_frequency
        u = [w/c,gamma*beta,w/c,gamma*beta,w/c,-gamma*beta*beta]
        return Numeric.array(u)
       
        
class Lattice_function_array:
    def __init__(self):
        self.s = []
        self.beta_x = []
        self.beta_y = []
        self.alpha_x = []
        self.alpha_y = []

    def append(self, lattice_fn):
        self.s.append(lattice_fn.arcLength)
        self.beta_x.append(lattice_fn.beta.hor)
        self.beta_y.append(lattice_fn.beta.ver)
        self.alpha_x.append(lattice_fn.alpha.hor)
        self.alpha_y.append(lattice_fn.alpha.ver)
