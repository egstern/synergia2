#ifndef HAVE_ECLOUD_ECLOUDEFIELDVORPAL2D_H
#define HAVE_ECLOUD_ECLOUDEFIELDVORPAL2D_H
#include <string>
#include <vector>
#include <cmath>
#include "synergia/utils/multi_array_typedefs.h"
#include "synergia/collective/rectangular_grid.h"
#include "synergia/utils/commxx.h"
#include "gsl/gsl_chebyshev.h" 
#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>

#include <boost/serialization/base_object.hpp>
#include <boost/serialization/utility.hpp>
#include <boost/serialization/list.hpp>
#include <boost/serialization/assume_abstract.hpp>
//
//  This is a small interface class between the e-cloud VORPAL (2D) analysis project and Synergia.
//  The idea is to run VORPAL 2d outside the realm of Synergia entirely. 
//  Since the most likely e-cloud problem is for the dipole, where the 2D approximation is valid. 
//   2D map of type "_YeeStaticElecFldTrilinos_ " are then generated by VORPAL 
// A VORPAL analysis tool, based on HDF5, GSL and the BOOST serialization & share pointer library 
// generates an archive of the field due to the e-cloud (i.e, not the proton bunch itself) 
// This small VORPAL analysis package does not need to be tightly integrated to Synergia,
// as it does not link nor run under Synergia per se. 
//
//  Once that archive of the 2D ECloud field is created, it can be restore in 
// the context of Synergia 
//
//  The propose interfact for this field map is as follow:
//
//
// October 2012 : adding MPI, broadcast the Chebychev polynoms. 
//
class ECloudEFieldVORPAL2D {

  public:
    ECloudEFieldVORPAL2D(); // empty constructor, such that multiple instances of this call can be load in list or vectors. 
    // To be used in the context of Synergia 
    ECloudEFieldVORPAL2D(const char *archiveName); // Expected constructor, from an archive file
    ECloudEFieldVORPAL2D(Commxx_sptr comm_sptr, const char *archiveName); // Expected constructor, from an archive file
    ~ECloudEFieldVORPAL2D();
                                                               
    bool loadFromFile(const char *archiveName); //loaded from a single file, a BOOST serialized binary, portable archive file 
    double GetFieldEX(double x, double y, double dz) const; // main work-horse accessor: the electric field at one location.  
                                                      // y is parallel to the dipole field, z long the beam and dz is the distance 
						      // from the bunch centroid. z > 0 mean the tail of the bunch. 
						  
    double GetFieldEY(double x, double y, double dz) const; // same as above, but gives the vertical component of the electric field. 
//
// Fitting into Synergia methodology.. Compute the field on a Synergia Rectangular grid.
//
    bool loadSynergia(const char *archiveName, 
                      boost::shared_ptr<Rectangular_grid> sGridEx, boost::shared_ptr<Rectangular_grid> sGridEy);
		       
// Assume the field is already loaded. 
		      
    bool loadSynergia(boost::shared_ptr<Rectangular_grid> sGridEx, boost::shared_ptr<Rectangular_grid> sGridEy);     
//
// In case we run out memory, we could think about cleaning up the local copies. i.e., overwrite the std::vector in the class 
// with blank ones. 
//
   void cleanup();     
    
//
// These accessor could almot (?) be implemeted online: along X and Z, a simple linear interpolation between 
// fixed vertical scans, for which a checbychev series will give an O.K. accuracy.    
// Now some ancillary information, so that we can trace back when and how this file was created.    
    
//    std::string GetVersion() const;
//    std::string GetVORPALJobName() const;
//    
//... See below...     

// Kitchen stuff
   
   class YScanAtX {
     public:
       YScanAtX();
       double x;
       std::vector<double> coefChebEX; // good old fashioned 
       std::vector<double> coefChebEY; // good old fashioned 
       friend std::ostream & operator<<(std::ostream &os, const ECloudEFieldVORPAL2D::YScanAtX &aPDF);
       friend std::istream & operator>>(std::istream &is, const ECloudEFieldVORPAL2D::YScanAtX &aPDF);
       friend class boost::serialization::access;
       template<class Archive>
           void serialize(Archive & ar, const unsigned int /* file_version */){
             ar & x & coefChebEX  & coefChebEY;
       }
   };

   class YXScanAtdZ {
     public:
       YXScanAtdZ();
       double dz;
       std::vector<ECloudEFieldVORPAL2D::YScanAtX> data; 
        
     friend std::ostream & operator<<(std::ostream &os, const ECloudEFieldVORPAL2D::YXScanAtdZ &aPDF);
     friend std::istream & operator>>(std::istream &is, const ECloudEFieldVORPAL2D::YXScanAtdZ &aPDF);
     friend class boost::serialization::access;
     template<class Archive>
           void serialize(Archive & ar, const unsigned int /* file_version */){
             ar & dz & data ;
       }
   };
   // The real meat 

   private:
     Commxx myComm; // The communicator 
     std::string version;  // I'll probably change my mind, so there it is..
     std::string VORPALJobName; // strictly ofr experts..
     int verticalChebychevOrder; // the order for the Chebyshev
     double yLow; // the lower limit of the map
     double yUp;  // the upper limit of the map.
     std::vector<YXScanAtdZ> data;  // vector along z. 
     mutable gsl_cheb_series *tCheb; // Content is volatile, as it's pointer to the series will keep chaning. 
//
// expected memory foot print :  
//  roughly 40 YXScanAtdZ (VORPAL time step of ~0.25 ns for a one ns bunch length) 
//  for each such dZ slices, about 32 YScanAtX, (the complete VORPAL grid was typically
//  dimensioned to 64, but we do care of what the field is far away from the beam..)
//  Next, the size  of a YScanAtX: 
//     verticalChebychevOrder=16 give reasonable accuracy ( better than 5%, to be check..) 
//     or 35 doubles + 128 bits for setting up the vectors.. 
//     so, in total : (80*(2+32*(5+2*17))*8) ~ 0.9 Mgb. or so... 
//   Set inline method getNumDoubles
// Such a field map would be valid for a MI dipole, an MI quadrupole and so forth. 
// They critically depend on the bunch length, so they would be valid at only one nergy. 
// 
// inlines accessors, implementation.. 
// 
   public: 
     inline std::string getVersion() const {return version;}
     inline std::string getVORPALJobName() const { return VORPALJobName;} 
     inline int getNumPtDZ() const {return data.size();}
     inline int getNumPtX() const {  if (data.size() == 0) return 0; return data[0].data.size(); }  
     inline int getNumChebCoef() const { return  verticalChebychevOrder; }
     inline int getNumDoubles() const {
       int nTot = 0;
       for (std::vector<YXScanAtdZ>::const_iterator itZ=data.begin(); itZ != data.end(); itZ++) {
         for(std::vector<ECloudEFieldVORPAL2D::YScanAtX>::const_iterator itXY=itZ->data.begin();
	              itXY != itZ->data.end(); itXY++) 
            nTot += 1 + itXY->coefChebEX.size() + itXY->coefChebEY.size(); // x + coeffs for Ex and EY
	 nTot++; // dz 
       }
       std::cerr << " num Y scans " << data[38].data.size() << 
                    " CoeffSize X " << data[38].data[2].coefChebEX.size() << std::endl;
       nTot+= 2; //yLow and yUp
       return nTot;
     }  
//
// Possibly some private function to ease implementation..
// VORPALING here: upload one Y scan, at a given dz, X, etc.... 
//  
     void loadOneScan(bool isEX, double dz, double x, double yLow, double yUp, 
                      size_t chebOrder,  gsl_cheb_series *chebSerie);
   
     void archiveIt(const char *fNameOut);
// Some setters.. 

     inline void setVersion(const char* c) {version=std::string(c);}
     inline void setVORPALJobName(const char* c){ VORPALJobName=std::string(c);} 
     inline void setYLimits(double l, double u){ yLow=l; yUp=u; if (tCheb != 0) {tCheb->a = yLow; tCheb->b = yUp;} } 
     
     
   private: 
   
     double GetFieldEAtdz(bool isX, std::vector<YXScanAtdZ>::const_iterator itZ, double x, double y) const;  
     double GetFieldEAtdzX(bool isX, std::vector<YScanAtX>::const_iterator itXZ, double y) const;  
   // 
   // I/O stuff
   //
	 
     friend std::ostream & operator<<(std::ostream &os, const ECloudEFieldVORPAL2D &aPDF);
     friend std::istream & operator>>(std::istream &is, const ECloudEFieldVORPAL2D &aPDF);
     friend class boost::serialization::access;
     template<class Archive>
           void serialize(Archive & ar, const unsigned int /* file_version */){
             ar & version & VORPALJobName & verticalChebychevOrder & yLow & yUp & data;
       }
     void broadcastIt();
     
};
#endif
